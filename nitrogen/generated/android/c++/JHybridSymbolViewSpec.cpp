///
/// JHybridSymbolViewSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "JHybridSymbolViewSpec.hpp"



#include <string>
#include <optional>

namespace margelo::nitro::nitrosymbols {

  jni::local_ref<JHybridSymbolViewSpec::jhybriddata> JHybridSymbolViewSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridSymbolViewSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridSymbolViewSpec::initHybrid),
    });
  }

  size_t JHybridSymbolViewSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  void JHybridSymbolViewSpec::dispose() noexcept {
    static const auto method = javaClassStatic()->getMethod<void()>("dispose");
    method(_javaPart);
  }

  std::string JHybridSymbolViewSpec::toString() {
    static const auto method = javaClassStatic()->getMethod<jni::JString()>("toString");
    auto javaString = method(_javaPart);
    return javaString->toStdString();
  }

  // Properties
  std::string JHybridSymbolViewSpec::getSymbolName() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getSymbolName");
    auto __result = method(_javaPart);
    return __result->toStdString();
  }
  void JHybridSymbolViewSpec::setSymbolName(const std::string& symbolName) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* symbolName */)>("setSymbolName");
    method(_javaPart, jni::make_jstring(symbolName));
  }
  std::optional<double> JHybridSymbolViewSpec::getPointSize() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JDouble>()>("getPointSize");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->value()) : std::nullopt;
  }
  void JHybridSymbolViewSpec::setPointSize(std::optional<double> pointSize) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JDouble> /* pointSize */)>("setPointSize");
    method(_javaPart, pointSize.has_value() ? jni::JDouble::valueOf(pointSize.value()) : nullptr);
  }
  std::optional<std::string> JHybridSymbolViewSpec::getWeight() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getWeight");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridSymbolViewSpec::setWeight(const std::optional<std::string>& weight) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* weight */)>("setWeight");
    method(_javaPart, weight.has_value() ? jni::make_jstring(weight.value()) : nullptr);
  }
  std::optional<std::string> JHybridSymbolViewSpec::getTintColor() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getTintColor");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridSymbolViewSpec::setTintColor(const std::optional<std::string>& tintColor) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* tintColor */)>("setTintColor");
    method(_javaPart, tintColor.has_value() ? jni::make_jstring(tintColor.value()) : nullptr);
  }
  std::optional<bool> JHybridSymbolViewSpec::getIsAnimating() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JBoolean>()>("getIsAnimating");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(static_cast<bool>(__result->value())) : std::nullopt;
  }
  void JHybridSymbolViewSpec::setIsAnimating(std::optional<bool> isAnimating) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JBoolean> /* isAnimating */)>("setIsAnimating");
    method(_javaPart, isAnimating.has_value() ? jni::JBoolean::valueOf(isAnimating.value()) : nullptr);
  }
  std::optional<std::string> JHybridSymbolViewSpec::getScale() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getScale");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridSymbolViewSpec::setScale(const std::optional<std::string>& scale) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* scale */)>("setScale");
    method(_javaPart, scale.has_value() ? jni::make_jstring(scale.value()) : nullptr);
  }
  std::optional<std::string> JHybridSymbolViewSpec::getEffect() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getEffect");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridSymbolViewSpec::setEffect(const std::optional<std::string>& effect) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* effect */)>("setEffect");
    method(_javaPart, effect.has_value() ? jni::make_jstring(effect.value()) : nullptr);
  }

  // Methods
  

} // namespace margelo::nitro::nitrosymbols
